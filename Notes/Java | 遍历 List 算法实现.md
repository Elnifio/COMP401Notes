# Java | 遍历 List 算法实现
> 遍历是什么，遍历是谁？遍历是什么意思出自哪里？ 今天小编就来帮助大家了解一下遍历到底是什么。  

一般我们在开发的时候，都需要对一个 list 进行遍历，访问这个 list 里面的所有元素。当然，这种简单的一次遍历并不难实现：

```Java
for (int i = 0; i < list.size(); i++) {
	print(list.get(i);
}
```

上面这个简单的 for loop 就能遍历整个 list 的元素了。

那么，对于更复杂的要求，我们怎么实现呢？
- - - -

> 设计一个函数，给定一个 list 和一个参数 n，我们需要将一个 List 中的元素往返遍历 n 次。  

例如：

list 内容为 `1 -> 2 -> 3 -> 4`，`n = 3`，则打印出来的内容应该为:

`1 -> 2 -> 3 -> 4 -> 4 -> 3 -> 2 -> 1 -> 1 -> 2 -> 3 -> 4`

观察上面打印的内容，我们可以看到这个列表总共遍历了 3 次，一次正向遍历，一次反向遍历，然后接着一次正向遍历。

（在这里为了简便考虑，使用 `int[]` 取代 list。

- - - -
##### 实现方案1 - Iteration 方案

- 代码如下：

![](Java%20%7C%20%E9%81%8D%E5%8E%86%20List%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/13520392-7BA3-4A6D-80B6-661A92D33658.png)
- 基础思路为：
	1. 设立 index 为 0
	2. 访问 index 指向的 element
	3. 对 index 进行操作：
		1. reverse 指示我们遍历的顺序 -> 正向是 false，反向为 true
		2. 如果需要反向遍历，则将 index 减去 1 -> 访问 index 前一个元素
		3. 如果需要正向遍历，则将 index 加上 1 -> 访问 index 后一个元素
	4. 注意，上一步我们对 index 进行操作的时候，index 是**有可能出界（也就是跑出 arr 的范围）的**，如果不对其进行处理则会报 `IndexOutOfRangeException`
	5. 因此，我们需要对其进行判断：
		1. 如果小于 0 -> 在这里，因为 index 都是整数，并且我们每次只减 1，所以 index 如果小于 0，则 index 一定是 -1 -> 此时，我们需要将index 重置为 0。与此同时，我们知道我们已经到了列表的头部，接下来需要正向遍历，因此我们将 reverse 设置为 false。
		2. 如果大于 size - 1 -> 同样是上面的原因，index > size - 1 的条件在这个函数中等同于 index == size。在这种情况下，我们需要将index 重置为 size - 1。与此同时，我们知道我们已经到了列表的尾部，接下来需要反向遍历，因此我们将 reverse 设置为 true。
	6. 接下来进行下一轮循环。

- 输出结果如下：

![](Java%20%7C%20%E9%81%8D%E5%8E%86%20List%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/93338823-5800-4B39-AF1C-E225E4EB6732.png)

- 在代码对应位置插入合适的 print 内容可以将输出结果进行“美化”：

![](Java%20%7C%20%E9%81%8D%E5%8E%86%20List%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/FFE3765D-F776-4778-8F28-A181993289D9.png)

- 输出结果如下：

![](Java%20%7C%20%E9%81%8D%E5%8E%86%20List%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/430952CB-C25C-4FA2-AC1D-C6797037ACB1.png)

- 假设 list 长度为 M，遍历次数为 N，则时间复杂度为 O(M * N)，空间复杂度为 O(1) （因为不需要开辟额外的新空间）。

- - - -
##### 实现方案1.5 - 改编为 Recursion
- 观察上面的代码，我们可以发现对于这个循环，我们需要将如下内容放入 recursion 的 parameter list 中：
	- array - 原始list
	- count - 输出次数计数
	- num - 输出总次数计数 - 可以省略如果我们从 num 开始往下减
	- reverse - 代表进行遍历的顺序
	- index - 代表访问的元素位置
- 具体方法不在这里赘述，大家可以自行尝试。
- - - -
##### 实现方案2 - 使用Stack
我们知道，stack 这种数据结构的一个非常重要的特性就是 **Last in First out**。因此，Stack 十分适合用于对链表内部内容进行反向。

Array-implemented Stack 代码实现如下：

![](Java%20%7C%20%E9%81%8D%E5%8E%86%20List%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/9716DEC3-A66D-423C-846A-7EDC4BEA7D56.png)

（为了不择手段的将图的大小缩小，这段代码的写法非常辣鸡，请务必**不要模仿**。哈哈哈哈哈哈哈哈。）

（这里选择使用 Array-implemented Stack，但是如果用 Linked-list-implemented Stack 也是可以的。只是 Array 写起来简单所以我选了写 Array）

使用这个 Stack 实现往返遍历的代码如下：

![](Java%20%7C%20%E9%81%8D%E5%8E%86%20List%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/31628510-0E4D-4219-B7E0-B743A5A7DCF5.png)

基础思路为：
1. 创建一个 Stack。
2. 检测 Stack **有没有元素** - 这里，因为只要检测到 Stack 没有满，我们就自动填充满整个 Stack，所以 `size == 0` 和 `size < arr.length` 的**理论效果**是一样的。
	1. 如果没有元素，则遍历整个 array，将 stack 按顺序填满，并且顺便顺序打印所有元素。
	2. 如果有元素，则将内容一个个从 stack 中抽出并打印，循环终止条件为 `size == 0` - 也就代表整个 stack 已经空了。
3. 将输出次数计数减少 1。

输出结果如下：

![](Java%20%7C%20%E9%81%8D%E5%8E%86%20List%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/C468F525-C3E6-4DC1-847A-5E8D440D2763.png)

同样的，在对应位置插入合适的print内容可以对结果进行（可以但没必要的）美化：

![](Java%20%7C%20%E9%81%8D%E5%8E%86%20List%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/0D516FF2-C5BB-44D7-B131-00ABBFDC6D4C.png)

输出结果如下：

![](Java%20%7C%20%E9%81%8D%E5%8E%86%20List%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/1739A048-928E-4387-801C-F1C8064EA981.png)

- 假设 List 长度为 M，遍历次数为 N，则时间复杂度为 O(M * N)，空间复杂度为 O(M)
- - - -
##### 更加 Generalize 的要求
> 现在，假设我们将需求改变一下 - 给定的循环次数不是一个整数，而是一个浮点数。  

例如，给定一个 list: `1 -> 2 -> 3`，循环次数为 2.5，则输出内容需要为：`1 -> 2 -> 3 -> 3 -> 2 -> 1 -> 1 -> 2` - 循环打印 list 2.5遍，向上取整。

对于这个问题，我们可以直接用前面的代码进行小部分更改就能完成这个要求。在这里，我们以 Stack implementation 进行演示，代码如下：

![](Java%20%7C%20%E9%81%8D%E5%8E%86%20List%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/521EF6BD-D378-41C2-B978-D82A62F981DF.png)

对于输入 `printList({1, 2, 3, 4}, 4.2)` 输出结果如下：

![](Java%20%7C%20%E9%81%8D%E5%8E%86%20List%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/D7772718-0D49-4607-BE5A-E5755508A3F2.png)
- - - -
##### 有什么用？
![](Java%20%7C%20%E9%81%8D%E5%8E%86%20List%20%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/D5EE3B9E-FE09-4C7A-B6CB-3CA9723AE42D.png)

我也不知道，哈哈哈哈哈哈哈哈。
