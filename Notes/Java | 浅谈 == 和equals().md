# Java | 浅谈 == 和equals()
> equals()是什么，equals()是谁？equals()是什么意思出自哪里？ 今天小编就来帮助大家了解一下equals()到底是什么。  

在使用 Java 开发的时候，我们经常被告知，在比较两个对象是否相等的时候需要用到`.equals()`这个方法，而不能直接使用 `==`。这背后有什么原因呢？

一般在编程的时候，我们需要比较两个值的大小。这时候根据直觉和之前在各种其他语言（点名 JavaScript 和 Python ）中，我们可以通过`==`来比较两个值的大小。实际上我们在Java中也可以这样做，示范如下：

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/7F213164-B4C7-4C3C-94DD-668F5AE3F27B.png)

在这个例子中，我们先让整数变量 a1 a2 分别赋值为2，然后进行判断：如果 a1 = a2，则输出 a1 = a2，反之则输出 a1 != a2
我们看一看程序运行的结果。

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/4830CE6A-E931-416C-BE26-546A4982D502.png)

可以看到，a1确实等于a2 - 毕竟2 = 2.

- - - -

那么现在，我们比较两个对象，结果会是怎样的呢？

我们来看看下面一个例子。

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/8D1793C2-7440-474C-B9E9-63DE7B516BCD.png)

在这一部分代码中，我们先在第三行定义了一个名叫 Test 的类，其有一个 Field (定义于第四行) 
和一个 method (定义于第八行) 绑定在对应的对象上。
然后我们在 Main 中新建两个实例 (第十一行和第十二行)，
可以看到他们的 object field 中的值是相同的（均为2）。

因此，如果我们直接运行这个程序，我们期望运行的结果是 true，
也就代表这两个 objects 是相同的。我们来看一下运行的结果：

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/A97FFE0A-7B3C-48C1-B4E6-9A804616EBE7.png)

可以看到，Java 并不认为这两个值相同。这是怎么回事呢？

实际上，Java 中的 `==` 运算符，比较的是两个对象的*内存地址* -> 也就是比较两个对象的指针是否指向同一个对象。

我们看一下这两个对象的内存地址：

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/89BE6A49-C0DB-4E11-AAA8-8E24D1A3CA27.png)

并没有指向同一个对象。

上面的程序画出 Environment Diagram 如下所示：

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/bear_sketch@2x.png)

- - - -

那么这时候，我们不用 `==`，改用`.equals()`方式来比较这两个对象，结果会是怎么样的呢？

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/4DC7C5E9-A55C-47D8-B087-E319A82A5278.png)

结果如下：

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/6BB4239F-9E96-406A-B029-01DACFD989AA.png)

依旧是false。我们来看一下这个 equals 的 declaration：

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/DE8F8A72-31FA-46F8-BDFA-8A3623CD37D3.png)

（上面的图可以通过选中 equals -> 右键 open declaration 定位至 Object.class文件）

那既然这里return的结果和 `==` 完全一样，为什么我们还要用equals呢？

因为这个method**可以被override**，如下图：

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/2110CCE0-96B9-4D5E-AB23-1BF1207E518A.png)

通过重新写这个method里面的内容，我们可以让`.equals`方法实现我们需要的需求。

运行结果如下：

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/2D69E32E-85F3-477E-BFA0-59E6B79668BD.png)

- 为什么是override这个特定的equals方法，一是因为约定俗成，
二是因为 Java 的 Object 类本身就定义了这个方法，如果我们也提供一个相同的方法的话会更一致。

- 至于说为什么这里没有`@Override`标签，我也不知道（笑

一个更加复杂的`equals()`例子如下：

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/9BED48FE-48FD-4B87-930E-5C4670F88BC8.png)

注意上面的代码中，对于String我们使用了`.equals()`，而对于int我们直接写了 `==`。
这是因为int这类 primitive data type 在存储的时候，**并不是作为对象来存储**，
而是直接存储到对应的slot。
我们在给某个变量赋值的时候，赋的值取决于等号右边的statement的值。
如果这个值是一个 Primitive Data Type (int, char, boolean等八个)，
Java就会直接将值赋值到这个变量中。而如果这个值是一个对象（Reference Data Type），
这时候Java会将*这个对象的内存地址*赋值到这个变量中，
画图如下：

![](Java%20%7C%20%E6%B5%85%E8%B0%88%20==%20%E5%92%8Cequals()/bear_sketch@2x%202.png)

在上面的图中，整数类型的变量 `a` 的值是 0，直接存储到 Stack 中。
字符串类型的变量`b`的实际值是`”hello”`，存在内存的`0x001`位置，于是变量`b`的值就是`0x001`。

- - - -

扯远了。实际上我们对于int等primitive data type变量不用`.equals()`方法是因为**他们不是Objects，没有这个方法**（笑

这就牵扯到另外一个很多人经常犯的问题，就是在比较某个对象是不是null的时候，经常会使用`.equals()`，
导致程序出各种bug但是死活de不出来。

为什么我们在比较null的时候，不能用`.equals()`？
简单来说，null本身**不是一个object**，所以如果一个变量是null，
那么它没有`.equals()`这个方法，也就会出现`NullPointerException`。
反过来讲，如果一个变量有`.equals()`方法，那么它一定不是null。

所以**必须要用 == 来比较某个值是否为null**（有 力 论 证）

大概好像也许关于 `==` 和 `.equals()` 内容就这么多？下一篇文章特别的对字符串类的值的比较进行探讨。

如果本文章有问题请务必在公众号后台留言指出。

> 好了，以上就是.equals()的含义和出处。希望小编精心整理的这篇内容能够解决你的困惑。  
