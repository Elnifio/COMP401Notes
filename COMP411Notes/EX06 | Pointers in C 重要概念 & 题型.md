# EX06 | Pointers in C 重要概念 & 题型
[[Index | COMP411]]
- - - -
## 重要概念
C 中的 pointer 相当于静态的保存了一个变量的地址。
在 C 中声明一个 Pointer 类型的语法：`int *`

##### C 指针的常规操作
对于一个 Pointer `int *p`，我们有如下操作：
- 给指针赋值：`p = &i`，将 i 的内存地址赋值给 p。此处 `&i` 代表 i 的**内存地址**
- 给指针指向的值赋值：`*p = 5`。指针 p 保存的是一个地址，此时使用 `*p` 代表访问 p 保存的地址，并且将 5 赋值给这个地址。也就是 “p 指向的变量赋值为 5”

##### C 中使用 Pointer 对 array 内部元素进行访问：
假设我们有一个 int array `int a[10]` 和一个 `int *p`，我们有如下操作：
- 访问这个 Array：`p = a` or `p = &a[0]`。
> 此处我们需要注意，C 中的数组声明实际上也是声明一个 pointer，指向一处连续的内存，这一段内存中保存了我们需要的所有数据。因此，对于一个 `int a[]`，实际上这个 a 变量也是一个指针，指向内存中这个 Array 的地址。  
> 因此，我们也可以不难得出：`a == &a[0]`。注意这里 `a[0]` 代表数组第一个元素的内存地址，也就是数组本身的地址（起始地址）。  

- 访问 array 的特定元素：`a[k] == *(p + k)` or `&a[k] == p + k`

如果我们需要访问数组中的某个元素，我们可以选择使用 `a[k]` 或者使用 `*(p+k)`，这两种表达是等效的。
> 例如，如果我们需要访问数组第一个元素，我们可以选择 `int b = a[0]`，也可以选择 `int b = *(a + 0)`。  
> 同样，如果我们需要访问数组第四个元素，我们可以选择 `int b = a[3]` 或者 `int b = *(a + 3)`。这两个表达是等价的。  

类似的，如果我们需要访问某个元素的地址，我们可以使用 `&a[k]` 或者使用 `a + k`，这两种表达是等效的。
> 例如，如果我们需要访问第一个元素的地址，我们可以使用 `int* p = a` 或者使用 `int* p = &a[0]`  
> 同样的，如果我们需要访问第四个元素的地址，我们使用 `int* p = (a+3)` 或者 `int* p = &a[3]`。  

注意事项：
> C 编译器自动帮我们计算了 array 里面的 objects 的大小。因此，如果我们需要访问数组第二个元素，我们只需要写 `*(a + 1)`，C 编译器自动帮我们将这个地址转换为 word offset。  
> 但是在 MIPS 里面不会自动转换，也就是说需要在 MIPS 中写 `a + 4`  来访问第二个元素（因为 MIPS 是 Byte-addressable 并且每个 word 是 4 bytes）  
- - - -
## 常见题型
#### 给定一段包含指针和变量的程序，计算运行后的结果
> Which of the following options has value of 20 after execution of the following code?   
```c
int x = 20;
int n = 5;
int *p1 = &n;
int *p2 = &x;
p1 = p2;
```
解题思路：通过 C 中 pointer 的性质来解决：
第一行声明 x = 20
第二行声明 n = 5
第三行声明 int 类型指针 p1 指向 n 的内存地址。
第四行声明 int 类型指针 p2 指向 x 的内存地址。
> 此时访问 p1，值为 n 的内存地址（例如 0x2fffd39c）  
> 类似的，p2 的值为 x 的内存地址。  
> （注意，如果需要访问对应的值，则需要加上星号，例如`*p1 = n = 5`，`*p2 = x = 20`）  
第五行将 p1 的值（目前存储的是 n 的内存地址）改变为 p2 的值（也就是 x 的内存地址）
所以运行完之后，我们可以知道：
1. `p1 = &x = p2`
2. `x = 20`
3. `n = 5`
因此，此时值为 20 的 expression 有`*p1`, `*p2`, `x`


#### 数组内指针的访问
> Select all of the following that represents the very first (0th) item of `vals`, where `vals` is an integer array with 10 elements:   
> A. `*vals`  
> B. `vals`  
> C. `*(vals + 10)`  
> D. `*vals[0]`  
> E. `*(vals + 0)`  
> F. `vals[0]`  
解题思路：根据上面数组的性质来解题即可。
通过套用性质，我们知道：
A 代表 vals 指向的内容，也就等价于 `vals[0]`
B 代表 vals 这个变量保存的数据，也就是这个数组的内存地址，不是数组的第一个元素。
C 代表的是 vals 所在地址 + 10，除非直接访问内存，我们不知道这是什么东西。（因为在内存中的存储不一定一定是连续的）
D 代表的是将 vals[0] 保存内容作为地址访问内存。
E 代表的是计算 vals 对应内存地址 + 0 后访问对应内容，也就是 vals 指向的内容，等价于 `vals[0]`
F 就是 `vals[0]`
因此正确答案是 A E F。


#archived/FALL2019/COMP411/上课笔记